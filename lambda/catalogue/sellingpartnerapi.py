# utilise le SDK Python d'Amazon SellingPartner
import requests
import urllib3
import re
import json
import os
import time



client_id = os.environ['client_id']
client_secret = os.environ['client_secret']

with open('refresh_token.txt', 'r') as f:
    refresh_token = f.readlines()[0]


pool_manager = urllib3.PoolManager()




def request(method, url, query_params=None, headers=None,
                body=None, post_params=None, _preload_content=True,
                _request_timeout=None):
        """Perform requests.

        :param method: http request method
        :param url: http request url
        :param query_params: query parameters in the url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request post parameters,
                            `application/x-www-form-urlencoded`
                            and `multipart/form-data`
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT',
                          'PATCH', 'OPTIONS']

        if post_params and body:
            raise ValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}

        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, ) if six.PY3 else (int, long)):  # noqa: E501,F821
                timeout = urllib3.Timeout(total=_request_timeout)
            elif (isinstance(_request_timeout, tuple) and
                  len(_request_timeout) == 2):
                timeout = urllib3.Timeout(
                    connect=_request_timeout[0], read=_request_timeout[1])

        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'

        try:
            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
                if query_params:
                    url += '?' + urlencode(query_params)
                if re.search('json', headers['Content-Type'], re.IGNORECASE):
                    request_body = None
                    if body is not None:
                        # PUT or POST
                        request_body = json.dumps(body)
                    r = pool_manager.request(
                        method, url,
                        body=request_body,
                        preload_content=_preload_content,
                        timeout=timeout,
                        headers=headers)
                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
                    r = pool_manager.request(
                        method, url,
                        fields=post_params,
                        encode_multipart=False,
                        preload_content=_preload_content,
                        timeout=timeout,
                        headers=headers)
                elif headers['Content-Type'] == 'multipart/form-data':
                    # must del headers['Content-Type'], or the correct
                    # Content-Type which generated by urllib3 will be
                    # overwritten.
                    del headers['Content-Type']
                    r = pool_manager.request(
                        method, url,
                        fields=post_params,
                        encode_multipart=True,
                        preload_content=_preload_content,
                        timeout=timeout,
                        headers=headers)
                # Pass a `string` parameter directly in the body to support
                # other content types than Json when `body` argument is
                # provided in serialized form
                elif isinstance(body, str):
                    request_body = body
                    r = pool_manager.request(
                        method, url,
                        body=request_body,
                        preload_content=_preload_content,
                        timeout=timeout,
                        headers=headers)
                else:
                    # Cannot generate the request from given parameters
                    msg = """Cannot prepare a request message for provided
                             arguments. Please check that your arguments match
                             declared content type."""
                    raise ApiException(status=0, reason=msg)
            # For `GET`, `HEAD`
            else:
                r = pool_manager.request(method, url,
                                              fields=query_params,
                                              preload_content=_preload_content,
                                              timeout=timeout,
                                              headers=headers)
        except urllib3.exceptions.SSLError as e:
            msg = "{0}\n{1}".format(type(e).__name__, str(e))
            raise ApiException(status=0, reason=msg)

        if _preload_content:
            r = RESTResponse(r)

            # In the python 3, the response.data is bytes.
            # we need to decode it to string.
            if six.PY3:
                r.data = r.data.decode('utf8')

            # log response body
            logger.debug("response body: %s", r.data)

        if not 200 <= r.status <= 299:
            #raise ApiException(http_resp=r)
            print(r.reason)
            print(r.status)
            print(r.data)

        return r

def GET(url, headers=None, query_params=None, _preload_content=True,
            _request_timeout=None):
    return request("GET", url,
                            headers=headers,
                            _preload_content=_preload_content,
                            _request_timeout=_request_timeout,
                            query_params=query_params)



def get_access_token_production_de_fr():
    
    data = {
            "client_id": client_id,
            "client_secret": client_secret,
            "grant_type": 'refresh_token',
             "refresh_token": refresh_token        
}

    response = requests.post("https://api.amazon.com/auth/o2/token", data=data)

    return response.json()


def catalogue(id_vendeur, id_marketplace, jeton_acces_de_fr):
    
    compteur = 0
    derniere_page_catalogue = False
    
    objets_catalogue = []
    
    headers_prod = {'Content-Type': 'application/json',
 'x-amz-access-token': jeton_acces_de_fr}
    
    type_jeton_page = ''
    
    jeton_page = ''
    
    while derniere_page_catalogue == False:
        
        compteur += 1
        
        print(compteur)
        
        url = 'https://sellingpartnerapi-eu.amazon.com/listings/2021-08-01/items/{id_vendeur}/?marketplaceIds={id_marketplace}&issueLocale =fr_Fr&pageSize=20'.format(id_vendeur = id_vendeur, id_marketplace = id_marketplace)
        
        if compteur > 1:
            
            url += '&pageToken={type_token_page}'.format(type_token_page = custom_url_encode_utf8(jeton_page))
        
        page_catalogue_reponse = request(method = "GET", url = url,
                            headers=headers_prod,
                            _preload_content=None,
                            _request_timeout=None,
                            query_params=None)
        
        
        time.sleep(2)
        
        page_catalogue_reponse = json.loads(page_catalogue_reponse.data)
        
        pagination = page_catalogue_reponse['pagination']
        type_jeton_page = list(pagination.keys())[0]
        
        print(type_jeton_page)
        
        page_catalogue = page_catalogue_reponse['items']
        
        if type_jeton_page == 'nextToken':
            
            jeton_page = pagination['nextToken']
            
            
            if compteur == 1:
                
                objets_catalogue = page_catalogue
                
            else:
                
                objets_catalogue += page_catalogue
                
        else:
            
            objets_catalogue += page_catalogue
            
            derniere_page_catalogue = True
            
    return objets_catalogue

def custom_url_encode_utf8(s):
    return ''.join('%%%02X' % b for b in s.encode('utf-8'))

